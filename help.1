'\" t
.\" Automatically generated by Pandoc 3.1.11.1
.\"
.TH "fzf\-search" "1" "Nov 2022" "Recursive search w/ FZF + RG" ""
.PP
Recursively search w/ FZF & Ripgrep
.SH Table of contents
.IP "1." 3
Usage (jump: \f[I]15g\f[R])
.IP "2." 3
Key bindings (jump: \f[I]35g\f[R])
.IP "3." 3
Ripgrep (Rust) Regex syntax (jump: \f[I]50g\f[R])
.IP "4." 3
FZF search syntax (jump: \f[I]243g\f[R])
.IP "5." 3
Upstream documentation (jump: \f[I]262g\f[R])
.SH Usage
.SS \f[CR]fzf\-search\f[R]
.IP
.EX
$ fzf\-search [PATH...]
.EE
.PP
The default behaviour is to search the current directory.
The files are discovered by \f[CR]rg\f[R], so you may customise file
discovery by using a Ripgrep configuration file.
You can set the \f[CR]RIPGREP_CONFIG_PATH\f[R] environment variable to
specify the file.
To search multiple directories, you can provide the list of paths as
positional arguments.
.PP
Ripgrep is executed with the \f[CR]\-\-smart\-case\f[R] option, which
implies a case insensitive search if the search query is all lower case,
but case sensitive otherwise.
.SS \f[CR]fzf\-file\f[R]
.IP
.EX
$ fzf\-file [PATH...]
.EE
.PP
Same as above, the default behaviour to filter files is to discover
files in the current directory.
However to filter through files in multiple directories, you can provide
a list of paths as positional arguments.
Files are discovered using \f[CR]rg \-\-files\f[R].
.SS Piped usage
.IP
.EX
$ find <dir> \-type d | QUERY=\[aq]foo bar\[aq] fzf\-search
.EE
.PP
Both scripts can be invoked on a list of files piped through the
scripts.
You can specify the search query during invocation by setting the
\f[CR]QUERY\f[R] environment variable to the query string.
.SH Key bindings
.TP
\f[B]F1\f[R]
show this help message
.TP
\f[B]C\-u\f[R]
recursive search \- start a new search session with the current file
.TP
\f[B]C\-s\f[R]
recursive search \- start a new search session with the current set of
files
.TP
\f[B]C\-f\f[R]
filter current set of files
.TP
\f[B]C\-l\f[R]
cancel search \- cancel current search and wait for new input
.TP
\f[B]RET\f[R]
view the current file in a pager
.TP
\f[B]M\-RET\f[R]
open the current file with \f[CR]$EDITOR\f[R]
.TP
\f[B]↑/↓\f[R]
scroll to previous/next matching file
.TP
\f[B]C\-↑/↓\f[R]
scroll preview window up/down
.SH Ripgrep (Rust) regex syntax
.SS Matching one character
.PP
.TS
tab(@);
cw(12.0n) lw(58.0n).
T{
Character
T}@T{
Description
T}
_
T{
\f[CR].\f[R]
T}@T{
any character except new line (includes new line with s flag)
T}
T{
\f[CR]\[rs]d\f[R]
T}@T{
digit (\f[CR]\[rs]p{Nd}\f[R])
T}
T{
\f[CR]\[rs]D\f[R]
T}@T{
not digit
T}
T{
\f[CR]\[rs]pN\f[R]
T}@T{
One\-letter name Unicode character class
T}
T{
\f[CR]\[rs]p{Greek}\f[R]
T}@T{
Unicode character class (general category or script)
T}
T{
\f[CR]\[rs]PN\f[R]
T}@T{
Negated one\-letter name Unicode character class
T}
T{
\f[CR]\[rs]P{Greek}\f[R]
T}@T{
negated Unicode character class (general category or script)
T}
.TE
.SS Character classes
.PP
.TS
tab(@);
cw(14.2n) lw(55.8n).
T{
Character class
T}@T{
Description
T}
_
T{
\f[CR][xyz]\f[R]
T}@T{
A character class matching either \f[CR]x\f[R], \f[CR]y\f[R] or
\f[CR]z\f[R] (union).
T}
T{
\f[CR][\[ha]xyz]\f[R]
T}@T{
A character class matching any character except \f[CR]x\f[R],
\f[CR]y\f[R] and \f[CR]z\f[R].
T}
T{
\f[CR][a\-z]\f[R]
T}@T{
A character class matching any character in range \f[CR]a\-z\f[R].
T}
T{
\f[CR][[:alpha:]]\f[R]
T}@T{
ASCII character class (\f[CR][A\-Za\-z]\f[R])
T}
T{
\f[CR][[:\[ha]alpha:]]\f[R]
T}@T{
Negated ASCII character class (\f[CR][\[ha]A\-Za\-z]\f[R])
T}
T{
\f[CR][x[\[ha]xyz]]\f[R]
T}@T{
Nested/grouping character class
T}
T{
T}@T{
(matching any character except \f[CR]y\f[R] and \f[CR]z\f[R])
T}
T{
\f[CR][a\-y&&xyz]\f[R]
T}@T{
Intersection (matching \f[CR]x\f[R] or \f[CR]y\f[R])
T}
T{
\f[CR][0\-9&&[\[ha]4]]\f[R]
T}@T{
Subtraction using intersection and negation
T}
T{
T}@T{
(matching \f[CR]0\-9\f[R] except \f[CR]4\f[R])
T}
T{
\f[CR][0\-9\-\-4]\f[R]
T}@T{
Direct subtraction (matching \f[CR]0\-9\f[R] except \f[CR]4\f[R])
T}
T{
\f[CR][a\-g\[ti]\[ti]b\-h]\f[R]
T}@T{
Symmetric difference (matching \f[CR]a\f[R] and \f[CR]h\f[R] only)
T}
T{
\f[CR][\[rs][\[rs]]]\f[R]
T}@T{
Escaping in character classes (matching \f[CR][\f[R] or \f[CR]]\f[R])
T}
.TE
.PP
Any named character class may appear inside a bracketed \f[CR][...]\f[R]
character class.
For example, \f[CR][\[rs]p{Greek}[:digit:]]\f[R] matches any Greek or
ASCII digit.
\f[CR][\[rs]p{Greek}&&\[rs]pL]\f[R] matches Greek letters.
Precedence in character classes, from most binding to least:
.IP "1." 3
Ranges: \f[CR]a\-cd\f[R] == \f[CR][a\-c]d\f[R]
.IP "2." 3
Union: \f[CR]ab&&bc\f[R] == \f[CR][ab]&&[bc]\f[R]
.IP "3." 3
Intersection: \f[CR]\[ha]a\-z&&b\f[R] == \f[CR]\[ha][a\-z&&b]\f[R]
.IP "4." 3
Negation
.SS Composites
.PP
.TS
tab(@);
c l.
T{
Composites
T}@T{
Description
T}
_
T{
\f[CR]xy\f[R]
T}@T{
concatenation (\f[CR]x\f[R] followed by \f[CR]y\f[R])
T}
T{
\f[CR]x|y\f[R]
T}@T{
alternation (\f[CR]x\f[R] or \f[CR]y\f[R], prefer \f[CR]x\f[R])
T}
.TE
.SS Repetitions
.PP
.TS
tab(@);
c l.
T{
Repetitions
T}@T{
Description
T}
_
T{
\f[CR]x*\f[R]
T}@T{
zero or more of \f[CR]x\f[R] (greedy)
T}
T{
\f[CR]x+\f[R]
T}@T{
one or more of \f[CR]x\f[R] (greedy)
T}
T{
\f[CR]x?\f[R]
T}@T{
zero or one of \f[CR]x\f[R] (greedy)
T}
T{
\f[CR]x*?\f[R]
T}@T{
zero or more of \f[CR]x\f[R] (ungreedy/lazy)
T}
T{
\f[CR]x+?\f[R]
T}@T{
one or more of \f[CR]x\f[R] (ungreedy/lazy)
T}
T{
\f[CR]x??\f[R]
T}@T{
zero or one of \f[CR]x\f[R] (ungreedy/lazy)
T}
T{
\f[CR]x{n,m}\f[R]
T}@T{
at least n \f[CR]x\f[R] and at most m \f[CR]x\f[R] (greedy)
T}
T{
\f[CR]x{n,}\f[R]
T}@T{
at least n \f[CR]x\f[R] (greedy)
T}
T{
\f[CR]x{n}\f[R]
T}@T{
exactly n \f[CR]x\f[R]
T}
T{
\f[CR]x{n,m}?\f[R]
T}@T{
at least n \f[CR]x\f[R] and at most m \f[CR]x\f[R] (ungreedy/lazy)
T}
T{
\f[CR]x{n,}?\f[R]
T}@T{
at least n \f[CR]x\f[R] (ungreedy/lazy)
T}
T{
\f[CR]x{n}?\f[R]
T}@T{
exactly n \f[CR]x\f[R]
T}
.TE
.SS Empty matches
.PP
.TS
tab(@);
c l.
T{
Empty matches
T}@T{
Description
T}
_
T{
\f[CR]\[ha]\f[R]
T}@T{
the beginning of text
T}
T{
T}@T{
(or start\-of\-line with multi\-line mode)
T}
T{
\f[CR]$\f[R]
T}@T{
the end of text
T}
T{
T}@T{
(or end\-of\-line with multi\-line mode)
T}
T{
\f[CR]\[rs]A\f[R]
T}@T{
only the beginning of text
T}
T{
T}@T{
(even with multi\-line mode enabled)
T}
T{
\f[CR]\[rs]z\f[R]
T}@T{
only the end of text
T}
T{
T}@T{
(even with multi\-line mode enabled)
T}
T{
\f[CR]\[rs]b\f[R]
T}@T{
a Unicode word boundary
T}
T{
T}@T{
(\f[CR]\[rs]w\f[R] on one side and \f[CR]\[rs]W\f[R], \f[CR]\[rs]A\f[R],
or \f[CR]\[rs]z\f[R] on other)
T}
T{
\f[CR]\[rs]B\f[R]
T}@T{
not a Unicode word boundary
T}
.TE
.PP
The empty regex is valid and matches the empty string.
For example, the empty regex matches \f[CR]abc\f[R] at positions
\f[CR]0\f[R], \f[CR]1\f[R], \f[CR]2\f[R] and \f[CR]3\f[R].
.SS Grouping and flags
.PP
.TS
tab(@);
c l.
T{
Groupings
T}@T{
Description
T}
_
T{
\f[CR](exp)\f[R]
T}@T{
numbered capture group
T}
T{
T}@T{
(indexed by opening parenthesis)
T}
T{
\f[CR](?P<name>exp)\f[R]
T}@T{
named (also numbered) capture group
T}
T{
T}@T{
(allowed chars: \f[CR][_0\-9a\-zA\-Z.\[rs][\[rs]]]\f[R])
T}
T{
\f[CR](?:exp)\f[R]
T}@T{
non\-capturing group
T}
T{
\f[CR](?flags)\f[R]
T}@T{
set flags within current group
T}
T{
\f[CR](?flags:exp)\f[R]
T}@T{
set flags for exp (non\-capturing)
T}
.TE
.PP
Flags are each a single character.
For example, \f[CR](?x)\f[R] sets the flag \f[CR]x\f[R] and
\f[CR](?\-x)\f[R] clears the flag \f[CR]x\f[R].
Multiple flags can be set or cleared at the same time: \f[CR](?xy)\f[R]
sets both the \f[CR]x\f[R] and \f[CR]y\f[R] flags and \f[CR](?x\-y)\f[R]
sets the \f[CR]x\f[R] flag and clears the \f[CR]y\f[R] flag.
All flags are by default disabled unless stated otherwise.
They are:
.PP
.TS
tab(@);
cw(7.0n) lw(63.0n).
T{
Flags
T}@T{
Description
T}
_
T{
\f[CR]i\f[R]
T}@T{
case\-insensitive: letters match both upper and lower case
T}
T{
\f[CR]m\f[R]
T}@T{
multi\-line mode: \f[CR]\[ha]\f[R] and \f[CR]$\f[R] match begin/end of
line
T}
T{
\f[CR]s\f[R]
T}@T{
allow \f[CR].\f[R] to match \f[CR]\[rs]n\f[R]
T}
T{
\f[CR]U\f[R]
T}@T{
swap the meaning of \f[CR]x*\f[R] and \f[CR]x*?\f[R]
T}
T{
\f[CR]u\f[R]
T}@T{
Unicode support (enabled by default)
T}
T{
\f[CR]x\f[R]
T}@T{
ignore whitespace and allow line comments (starting with \f[CR]#\f[R])
T}
.TE
.PP
Flags can be toggled within a pattern.
Here\[cq]s an example that matches case\-insensitively for the first
part but case\-sensitively for the second part:
.IP
.EX
# use regex::Regex;
# fn main() {
let re = Regex::new(r\[dq](?i)a+(?\-i)b+\[dq]).unwrap();
let cap = re.captures(\[dq]AaAaAbbBBBb\[dq]).unwrap();
assert_eq!(&cap[0], \[dq]AaAaAbb\[dq]);
# }
.EE
.PP
Notice that the \f[CR]a+\f[R] matches either \f[CR]a\f[R] or
\f[CR]A\f[R], but the \f[CR]b+\f[R] only matches \f[CR]b\f[R].
Multi\-line mode means \f[CR]\[ha]\f[R] and \f[CR]$\f[R] no longer match
just at the beginning/end of the input, but at the beginning/end of
lines:
.IP
.EX
# use regex::Regex;
let re = Regex::new(r\[dq](?m)\[ha]line \[rs]d+\[dq]).unwrap();
let m = re.find(\[dq]line one\[rs]nline 2\[rs]n\[dq]).unwrap();
assert_eq!(m.as_str(), \[dq]line 2\[dq]);
.EE
.PP
Note that \f[CR]\[ha]\f[R] matches after new lines, even at the end of
input:
.IP
.EX
# use regex::Regex;
let re = Regex::new(r\[dq](?m)\[ha]\[dq]).unwrap();
let m = re.find_iter(\[dq]test\[rs]n\[dq]).last().unwrap();
assert_eq!((m.start(), m.end()), (5, 5));
.EE
.PP
Here is an example that uses an ASCII word boundary instead of a Unicode
word boundary:
.IP
.EX
# use regex::Regex;
# fn main() {
let re = Regex::new(r\[dq](?\-u:\[rs]b).+(?\-u:\[rs]b)\[dq]).unwrap();
let cap = re.captures(\[dq]$$abc$$\[dq]).unwrap();
assert_eq!(&cap[0], \[dq]abc\[dq]);
# }
.EE
.SS Escape sequences
.PP
.TS
tab(@);
cw(14.0n) lw(56.0n).
T{
Escape sequence
T}@T{
Description
T}
_
T{
\f[CR]\[rs]*\f[R]
T}@T{
literal \f[CR]*\f[R], works for any punctuation character:
\f[CR]\[rs].+*?()|[]{}\[ha]$\f[R]
T}
T{
\f[CR]\[rs]a\f[R]
T}@T{
bell (\f[CR]\[rs]x07\f[R])
T}
T{
\f[CR]\[rs]f\f[R]
T}@T{
form feed (\f[CR]\[rs]x0C\f[R])
T}
T{
\f[CR]\[rs]t\f[R]
T}@T{
horizontal tab
T}
T{
\f[CR]\[rs]n\f[R]
T}@T{
new line
T}
T{
\f[CR]\[rs]r\f[R]
T}@T{
carriage return
T}
T{
\f[CR]\[rs]v\f[R]
T}@T{
vertical tab (\f[CR]\[rs]x0B\f[R])
T}
T{
\f[CR]\[rs]123\f[R]
T}@T{
octal character code (up to three digits) (when enabled)
T}
T{
\f[CR]\[rs]x7F\f[R]
T}@T{
hex character code (exactly two digits)
T}
T{
\f[CR]\[rs]x{10FFFF}\f[R]
T}@T{
any hex character code corresponding to a Unicode code point
T}
T{
\f[CR]\[rs]u007F\f[R]
T}@T{
hex character code (exactly four digits)
T}
T{
\f[CR]\[rs]u{7F}\f[R]
T}@T{
any hex character code corresponding to a Unicode code point
T}
T{
\f[CR]\[rs]U0000007F\f[R]
T}@T{
hex character code (exactly eight digits)
T}
T{
\f[CR]\[rs]U{7F}\f[R]
T}@T{
any hex character code corresponding to a Unicode code point
T}
.TE
.SS Perl character classes (Unicode friendly)
These classes are based on the definitions provided in \c
.UR https://www.unicode.org/reports/tr18/#Compatibility_Properties
UTS#18
.UE \c
:
.PP
.TS
tab(@);
cw(17.0n) lw(53.0n).
T{
Character class
T}@T{
Description
T}
_
T{
\f[CR]\[rs]d\f[R]
T}@T{
digit (\f[CR]\[rs]p{Nd}\f[R])
T}
T{
\f[CR]\[rs]D\f[R]
T}@T{
not digit
T}
T{
\f[CR]\[rs]s\f[R]
T}@T{
whitespace (\f[CR]\[rs]p{White_Space}\f[R])
T}
T{
\f[CR]\[rs]S\f[R]
T}@T{
not whitespace
T}
T{
\f[CR]\[rs]w\f[R]
T}@T{
word character
T}
T{
T}@T{
(\f[CR]\[rs]p{Alphabetic}+\[rs]p{M}+\[rs]d+\[rs]p{Pc}+\[rs]p{Join_Control}\f[R])
T}
T{
\f[CR]\[rs]W\f[R]
T}@T{
not word character
T}
.TE
.SS ASCII character classes
.PP
.TS
tab(@);
c l.
T{
Character class
T}@T{
Description
T}
_
T{
\f[CR][[:alnum:]]\f[R]
T}@T{
alphanumeric (\f[CR][0\-9A\-Za\-z]\f[R])
T}
T{
\f[CR][[:alpha:]]\f[R]
T}@T{
alphabetic (\f[CR][A\-Za\-z]\f[R])
T}
T{
\f[CR][[:ascii:]]\f[R]
T}@T{
ASCII (\f[CR][\[rs]x00\-\[rs]x7F]\f[R])
T}
T{
\f[CR][[:blank:]]\f[R]
T}@T{
blank (\f[CR][\[rs]t ]\f[R])
T}
T{
\f[CR][[:cntrl:]]\f[R]
T}@T{
control (\f[CR][\[rs]x00\-\[rs]x1F\[rs]x7F]\f[R])
T}
T{
\f[CR][[:digit:]]\f[R]
T}@T{
digits (\f[CR][0\-9]\f[R])
T}
T{
\f[CR][[:graph:]]\f[R]
T}@T{
graphical (\f[CR][!\-\[ti]]\f[R])
T}
T{
\f[CR][[:lower:]]\f[R]
T}@T{
lower case (\f[CR][a\-z]\f[R])
T}
T{
\f[CR][[:print:]]\f[R]
T}@T{
printable (\f[CR][ \-\[ti]]\f[R])
T}
T{
\f[CR][[:punct:]]\f[R]
T}@T{
punctuation (\f[CR][!\-/:\-\[at]\[rs][\-\[ga]\[ga]{\-\[ti]]\f[R])
T}
T{
\f[CR][[:space:]]\f[R]
T}@T{
whitespace (\f[CR][\[rs]t\[rs]n\[rs]v\[rs]f\[rs]r ]\f[R])
T}
T{
\f[CR][[:upper:]]\f[R]
T}@T{
upper case (\f[CR][A\-Z]\f[R])
T}
T{
\f[CR][[:word:]]\f[R]
T}@T{
word characters (\f[CR][0\-9A\-Za\-z_]\f[R])
T}
T{
\f[CR][[:xdigit:]]\f[R]
T}@T{
hex digit (\f[CR][0\-9A\-Fa\-f]\f[R])
T}
.TE
.SH FZF search syntax
Unless otherwise specified, fzf starts in \[lq]extended\-search
mode\[rq] where you can type in multiple search terms delimited by
spaces.
e.g.\ \f[CR]\[ha]music .mp3$ sbtrkt !fire\f[R]
.PP
.TS
tab(@);
cw(10.0n) lw(25.5n) lw(34.5n).
T{
Token
T}@T{
Match type
T}@T{
Description
T}
_
T{
\f[CR]sbtrkt\f[R]
T}@T{
fuzzy\-match
T}@T{
Items that match \f[CR]sbtrkt\f[R]
T}
T{
\f[CR]\[aq]wild\f[R]
T}@T{
exact\-match (quoted)
T}@T{
Items that include \f[CR]wild\f[R]
T}
T{
\f[CR]\[ha]music\f[R]
T}@T{
prefix\-exact\-match
T}@T{
Items that start with \f[CR]music\f[R]
T}
T{
\f[CR].mp3$\f[R]
T}@T{
suffix\-exact\-match
T}@T{
Items that end with \f[CR].mp3\f[R]
T}
T{
\f[CR]!fire\f[R]
T}@T{
inverse\-exact\-match
T}@T{
Items that do not include \f[CR]fire\f[R]
T}
T{
\f[CR]!\[ha]music\f[R]
T}@T{
inverse\-prefix\-exact\-match
T}@T{
Items that do not start with \f[CR]music\f[R]
T}
T{
\f[CR]!.mp3$\f[R]
T}@T{
inverse\-suffix\-exact\-match
T}@T{
Items that do not end with \f[CR].mp3\f[R]
T}
.TE
.PP
If you don\[cq]t prefer fuzzy matching and do not wish to
\[lq]quote\[rq] every word, start fzf with \f[CR]\-e\f[R] or
\f[CR]\-\-exact\f[R] option.
Note that when \f[CR]\-\-exact\f[R] is set, \f[CR]\[aq]\f[R]\-prefix
\[lq]unquotes\[rq] the term.
.PP
A single bar character term acts as an OR operator.
For example, the following query matches entries that start with
\f[CR]core\f[R] and end with either \f[CR]go\f[R], \f[CR]rb\f[R], or
\f[CR]py\f[R].
.IP
.EX
\[ha]core go$ | rb$ | py$
.EE
.SH Upstream documentation
https://docs.rs/regex/latest/regex/index.html#syntax
.PP
https://github.com/junegunn/fzf/blob/master/README.md
.SH AUTHORS
Suvayu Ali.
