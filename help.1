'\" t
.\" Automatically generated by Pandoc 2.14.0.3
.\"
.TH "fzf-search" "1" "Nov 2022" "Recursive search w/ FZF + RG" ""
.hy
.PP
Recursively search w/ FZF & Ripgrep
.SH Table of contents
.IP "1." 3
Key bindings (jump: \f[I]14g\f[R])
.IP "2." 3
Ripgrep (Rust) Regex syntax (jump: \f[I]25g\f[R])
.IP "3." 3
FZF search syntax (jump: \f[I]210g\f[R])
.IP "4." 3
Upstream documentation (jump: \f[I]229g\f[R])
.SH Key bindings
.TP
\f[B]F1\f[R]
this help message
.TP
\f[B]C-s\f[R]
recursive search - start a new search session with the current set of
files
.TP
\f[B]C-f\f[R]
filter current set of files
.TP
\f[B]RET\f[R]
view the current file in a pager
.TP
\f[B]M-RET\f[R]
open the current file with \f[C]$EDITOR\f[R]
.SH Ripgrep (Rust) regex syntax
.SS Matching one character
.PP
.TS
tab(@);
c l.
T{
Character
T}@T{
Description
T}
_
T{
\&.
T}@T{
any character except new line (includes new line with s flag)
T}
T{
\[rs]d
T}@T{
digit (\[rs]p{Nd})
T}
T{
\[rs]D
T}@T{
not digit
T}
T{
\[rs]pN
T}@T{
One-letter name Unicode character class
T}
T{
\[rs]p{Greek}
T}@T{
Unicode character class (general category or script)
T}
T{
\[rs]PN
T}@T{
Negated one-letter name Unicode character class
T}
T{
\[rs]P{Greek}
T}@T{
negated Unicode character class (general category or script)
T}
.TE
.SS Character classes
.PP
.TS
tab(@);
c l.
T{
Character class
T}@T{
Description
T}
_
T{
[xyz]
T}@T{
A character class matching either x, y or z (union).
T}
T{
[\[ha]xyz]
T}@T{
A character class matching any character except x, y and z.
T}
T{
[a-z]
T}@T{
A character class matching any character in range a-z.
T}
T{
[[:alpha:]]
T}@T{
ASCII character class ([A-Za-z])
T}
T{
[[:\[ha]alpha:]]
T}@T{
Negated ASCII character class ([\[ha]A-Za-z])
T}
T{
[x[\[ha]xyz]]
T}@T{
Nested/grouping character class
T}
T{
T}@T{
(matching any character except y and z)
T}
T{
[a-y&&xyz]
T}@T{
Intersection (matching x or y)
T}
T{
[0-9&&[\[ha]4]]
T}@T{
Subtraction using intersection and negation
T}
T{
T}@T{
(matching 0-9 except 4)
T}
T{
[0-9\[en]4]
T}@T{
Direct subtraction (matching 0-9 except 4)
T}
T{
[a-g\[ti]\[ti]b-h]
T}@T{
Symmetric difference (matching \f[I]a\f[R] and \f[I]h\f[R] only)
T}
T{
[\[rs][\[rs]]]
T}@T{
Escaping in character classes (matching [ or ])
T}
.TE
.PP
Any named character class may appear inside a bracketed
\f[I][\&...]\f[R] character class.
For example, \f[I][\[rs]p{Greek}[:digit:]]\f[R] matches any Greek or
ASCII digit.
\f[I][\[rs]p{Greek}&&\[rs]pL]\f[R] matches Greek letters.
Precedence in character classes, from most binding to least:
.IP "1." 3
Ranges: \f[I]a-cd\f[R] == \f[I][a-c]d\f[R]
.IP "2." 3
Union: \f[I]ab&&bc\f[R] == \f[I][ab]&&[bc]\f[R]
.IP "3." 3
Intersection: \f[I]\[ha]a-z&&b\f[R] == \f[I]\[ha][a-z&&b]\f[R]
.IP "4." 3
Negation
.SS Composites
.PP
.TS
tab(@);
c l.
T{
Composites
T}@T{
Description
T}
_
T{
xy
T}@T{
concatenation (x followed by y)
T}
T{
x|y
T}@T{
alternation (x or y, prefer x)
T}
.TE
.SS Repetitions
.PP
.TS
tab(@);
c l.
T{
Repetitions
T}@T{
Description
T}
_
T{
x*
T}@T{
zero or more of x (greedy)
T}
T{
x+
T}@T{
one or more of x (greedy)
T}
T{
x?
T}@T{
zero or one of x (greedy)
T}
T{
x*?
T}@T{
zero or more of x (ungreedy/lazy)
T}
T{
x+?
T}@T{
one or more of x (ungreedy/lazy)
T}
T{
x??
T}@T{
zero or one of x (ungreedy/lazy)
T}
T{
x{n,m}
T}@T{
at least n x and at most m x (greedy)
T}
T{
x{n,}
T}@T{
at least n x (greedy)
T}
T{
x{n}
T}@T{
exactly n x
T}
T{
x{n,m}?
T}@T{
at least n x and at most m x (ungreedy/lazy)
T}
T{
x{n,}?
T}@T{
at least n x (ungreedy/lazy)
T}
T{
x{n}?
T}@T{
exactly n x
T}
.TE
.SS Empty matches
.PP
.TS
tab(@);
c l.
T{
Empty matches
T}@T{
Description
T}
_
T{
\[ha]
T}@T{
the beginning of text
T}
T{
T}@T{
(or start-of-line with multi-line mode)
T}
T{
$
T}@T{
the end of text
T}
T{
T}@T{
(or end-of-line with multi-line mode)
T}
T{
\[rs]A
T}@T{
only the beginning of text
T}
T{
T}@T{
(even with multi-line mode enabled)
T}
T{
\[rs]z
T}@T{
only the end of text
T}
T{
T}@T{
(even with multi-line mode enabled)
T}
T{
\[rs]b
T}@T{
a Unicode word boundary
T}
T{
T}@T{
(\[rs]w on one side and \[rs]W, \[rs]A, or \[rs]z on other)
T}
T{
\[rs]B
T}@T{
not a Unicode word boundary
T}
.TE
.PP
The empty regex is valid and matches the empty string.
For example, the empty regex matches \f[I]abc\f[R] at positions
\f[I]0\f[R], \f[I]1\f[R], \f[I]2\f[R] and \f[I]3\f[R].
.SS Grouping and flags
.PP
.TS
tab(@);
c l.
T{
Groupings
T}@T{
Description
T}
_
T{
(exp)
T}@T{
numbered capture group
T}
T{
T}@T{
(indexed by opening parenthesis)
T}
T{
(?P<name>exp)
T}@T{
named (also numbered) capture group
T}
T{
T}@T{
(allowed chars: [_0-9a-zA-Z.\[rs][\[rs]]])
T}
T{
(?:exp)
T}@T{
non-capturing group
T}
T{
(?flags)
T}@T{
set flags within current group
T}
T{
(?flags:exp)
T}@T{
set flags for exp (non-capturing)
T}
.TE
.PP
Flags are each a single character.
For example, \f[I](?x)\f[R] sets the flag \f[I]x\f[R] and
\f[I](?-x)\f[R] clears the flag \f[I]x\f[R].
Multiple flags can be set or cleared at the same time: \f[I](?xy)\f[R]
sets both the \f[I]x\f[R] and \f[I]y\f[R] flags and \f[I](?x-y)\f[R]
sets the \f[I]x\f[R] flag and clears the \f[I]y\f[R] flag.
All flags are by default disabled unless stated otherwise.
They are:
.PP
.TS
tab(@);
c l.
T{
Flags
T}@T{
Description
T}
_
T{
i
T}@T{
case-insensitive: letters match both upper and lower case
T}
T{
m
T}@T{
multi-line mode: \[ha] and $ match begin/end of line
T}
T{
s
T}@T{
allow .
to match \[rs]n
T}
T{
U
T}@T{
swap the meaning of x* and x*?
T}
T{
u
T}@T{
Unicode support (enabled by default)
T}
T{
x
T}@T{
ignore whitespace and allow line comments (starting with \f[I]#\f[R])
T}
.TE
.PP
Flags can be toggled within a pattern.
Here\[cq]s an example that matches case-insensitively for the first part
but case-sensitively for the second part:
.IP
.nf
\f[C]
# use regex::Regex;
# fn main() {
let re = Regex::new(r\[dq](?i)a+(?-i)b+\[dq]).unwrap();
let cap = re.captures(\[dq]AaAaAbbBBBb\[dq]).unwrap();
assert_eq!(&cap[0], \[dq]AaAaAbb\[dq]);
# }
\f[R]
.fi
.PP
Notice that the \f[I]a+\f[R] matches either \f[I]a\f[R] or \f[I]A\f[R],
but the \f[I]b+\f[R] only matches \f[I]b\f[R].
Multi-line mode means \f[I]\[ha]\f[R] and \f[I]$\f[R] no longer match
just at the beginning/end of the input, but at the beginning/end of
lines:
.IP
.nf
\f[C]
# use regex::Regex;
let re = Regex::new(r\[dq](?m)\[ha]line \[rs]d+\[dq]).unwrap();
let m = re.find(\[dq]line one\[rs]nline 2\[rs]n\[dq]).unwrap();
assert_eq!(m.as_str(), \[dq]line 2\[dq]);
\f[R]
.fi
.PP
Note that \f[I]\[ha]\f[R] matches after new lines, even at the end of
input:
.IP
.nf
\f[C]
# use regex::Regex;
let re = Regex::new(r\[dq](?m)\[ha]\[dq]).unwrap();
let m = re.find_iter(\[dq]test\[rs]n\[dq]).last().unwrap();
assert_eq!((m.start(), m.end()), (5, 5));
\f[R]
.fi
.PP
Here is an example that uses an ASCII word boundary instead of a Unicode
word boundary:
.IP
.nf
\f[C]
# use regex::Regex;
# fn main() {
let re = Regex::new(r\[dq](?-u:\[rs]b).+(?-u:\[rs]b)\[dq]).unwrap();
let cap = re.captures(\[dq]$$abc$$\[dq]).unwrap();
assert_eq!(&cap[0], \[dq]abc\[dq]);
# }
\f[R]
.fi
.SS Escape sequences
.PP
.TS
tab(@);
c l.
T{
Escape sequence
T}@T{
Description
T}
_
T{
\[rs]*
T}@T{
literal *, works for any punctuation character: \[rs].+*?()
T}
T{
\[rs]a
T}@T{
bell (\[rs]x07)
T}
T{
\[rs]f
T}@T{
form feed (\[rs]x0C)
T}
T{
\[rs]t
T}@T{
horizontal tab
T}
T{
\[rs]n
T}@T{
new line
T}
T{
\[rs]r
T}@T{
carriage return
T}
T{
\[rs]v
T}@T{
vertical tab (\[rs]x0B)
T}
T{
\[rs]123
T}@T{
octal character code (up to three digits) (when enabled)
T}
T{
\[rs]x7F
T}@T{
hex character code (exactly two digits)
T}
T{
\[rs]x{10FFFF}
T}@T{
any hex character code corresponding to a Unicode code point
T}
T{
\[rs]u007F
T}@T{
hex character code (exactly four digits)
T}
T{
\[rs]u{7F}
T}@T{
any hex character code corresponding to a Unicode code point
T}
T{
\[rs]U0000007F
T}@T{
hex character code (exactly eight digits)
T}
T{
\[rs]U{7F}
T}@T{
any hex character code corresponding to a Unicode code point
T}
.TE
.SS Perl character classes (Unicode friendly)
.PP
These classes are based on the definitions provided in
UTS#18 (https://www.unicode.org/reports/tr18/#Compatibility_Properties):
.PP
.TS
tab(@);
c l.
T{
Character class
T}@T{
Description
T}
_
T{
\[rs]d
T}@T{
digit (\[rs]p{Nd})
T}
T{
\[rs]D
T}@T{
not digit
T}
T{
\[rs]s
T}@T{
whitespace (\[rs]p{White_Space})
T}
T{
\[rs]S
T}@T{
not whitespace
T}
T{
\[rs]w
T}@T{
word character
T}
T{
T}@T{
(\[rs]p{Alphabetic}+\[rs]p{M}+\[rs]d+\[rs]p{Pc}+\[rs]p{Join_Control})
T}
T{
\[rs]W
T}@T{
not word character
T}
.TE
.SS ASCII character classes
.PP
.TS
tab(@);
c l.
T{
Character class
T}@T{
Description
T}
_
T{
[[:alnum:]]
T}@T{
alphanumeric ([0-9A-Za-z])
T}
T{
[[:alpha:]]
T}@T{
alphabetic ([A-Za-z])
T}
T{
[[:ascii:]]
T}@T{
ASCII ([\[rs]x00-\[rs]x7F])
T}
T{
[[:blank:]]
T}@T{
blank ([\[rs]t ])
T}
T{
[[:cntrl:]]
T}@T{
control ([\[rs]x00-\[rs]x1F\[rs]x7F])
T}
T{
[[:digit:]]
T}@T{
digits ([0-9])
T}
T{
[[:graph:]]
T}@T{
graphical ([!-\[ti]])
T}
T{
[[:lower:]]
T}@T{
lower case ([a-z])
T}
T{
[[:print:]]
T}@T{
printable ([ -\[ti]])
T}
T{
[[:punct:]]
T}@T{
punctuation ([!-/:-\[at]\[rs][-\[ga]{-\[ti]])
T}
T{
[[:space:]]
T}@T{
whitespace ([\[rs]t\[rs]n\[rs]v\[rs]f\[rs]r ])
T}
T{
[[:upper:]]
T}@T{
upper case ([A-Z])
T}
T{
[[:word:]]
T}@T{
word characters ([0-9A-Za-z_])
T}
T{
[[:xdigit:]]
T}@T{
hex digit ([0-9A-Fa-f])
T}
.TE
.SH FZF search syntax
.PP
Unless otherwise specified, fzf starts in \[lq]extended-search mode\[rq]
where you can type in multiple search terms delimited by spaces.
e.g.\ \f[I]\[ha]music .mp3$ sbtrkt !fire\f[R]
.PP
.TS
tab(@);
c l l.
T{
Token
T}@T{
Match type
T}@T{
Description
T}
_
T{
\f[I]sbtrkt\f[R]
T}@T{
fuzzy-match
T}@T{
Items that match \f[I]sbtrkt\f[R]
T}
T{
\f[I]\[cq]wild\f[R]
T}@T{
exact-match (quoted)
T}@T{
Items that include \f[I]wild\f[R]
T}
T{
\f[I]\[ha]music\f[R]
T}@T{
prefix-exact-match
T}@T{
Items that start with \f[I]music\f[R]
T}
T{
\f[I].mp3$\f[R]
T}@T{
suffix-exact-match
T}@T{
Items that end with \f[I].mp3\f[R]
T}
T{
\f[I]!fire\f[R]
T}@T{
inverse-exact-match
T}@T{
Items that do not include \f[I]fire\f[R]
T}
T{
\f[I]!\[ha]music\f[R]
T}@T{
inverse-prefix-exact-match
T}@T{
Items that do not start with \f[I]music\f[R]
T}
T{
\f[I]!.mp3$\f[R]
T}@T{
inverse-suffix-exact-match
T}@T{
Items that do not end with \f[I].mp3\f[R]
T}
.TE
.PP
If you don\[cq]t prefer fuzzy matching and do not wish to
\[lq]quote\[rq] every word, start fzf with \f[I]-e\f[R] or
\f[I]\[en]exact\f[R] option.
Note that when \f[I]\[en]exact\f[R] is set, \f[I]\[cq]\f[R]-prefix
\[lq]unquotes\[rq] the term.
.PP
A single bar character term acts as an OR operator.
For example, the following query matches entries that start with
\f[I]core\f[R] and end with either \f[I]go\f[R], \f[I]rb\f[R], or
\f[I]py\f[R].
.IP
.nf
\f[C]
\[ha]core go$ | rb$ | py$
\f[R]
.fi
.SH Upstream documentation
.PP
https://docs.rs/regex/latest/regex/index.html#syntax
.PP
https://github.com/junegunn/fzf/blob/master/README.md
.SH AUTHORS
Suvayu Ali.
